<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flappy Mini</title>
<style>
  html,body{height:100%;margin:0;background:#70c5ce;display:flex;align-items:center;justify-content:center}
  #game{width:100%;max-width:480px;height:720px;background:linear-gradient(#70c5ce,#4eb6c3);border-radius:12px;overflow:hidden;box-shadow:0 8px 30px rgba(0,0,0,0.25);position:relative;-webkit-user-select:none;}
  canvas{display:block;width:100%;height:100%}
  #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(0,0,0,0.6);color:#fff;padding:18px 20px;border-radius:10px;text-align:center}
  .btn{background:#ffd66b;color:#222;padding:10px 14px;border-radius:8px;border:none;margin-top:10px;font-weight:700;cursor:pointer}
  .hud{position:absolute;top:12px;left:12px;color:#fff;font-weight:700;text-shadow:0 2px 4px rgba(0,0,0,0.4)}
  .score{position:absolute;top:12px;right:12px;color:#fff;font-weight:700;text-shadow:0 2px 4px rgba(0,0,0,0.4)}
  @media (max-width:480px){ #game{height:calc(100vh - 24px);border-radius:6px} }
</style>
</head>
<body>
<div id="game">
  <canvas id="c"></canvas>
  <div id="overlay"><div class="panel" id="menu"><h2 style="margin:0 0 6px">Flappy Mini</h2><div>Tap/click or press Space to flap.</div><button class="btn" id="startBtn">Start</button></div></div>
  <div class="hud" id="hud">Ready</div>
  <div class="score" id="score">0</div>
</div>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const devicePixelRatio = window.devicePixelRatio || 1;
  function resize(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * devicePixelRatio);
    canvas.height = Math.floor(rect.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // game state
  let w = canvas.width / devicePixelRatio, h = canvas.height / devicePixelRatio;
  let bird = {x:80,y: h/2, vy:0, radius:14};
  const gravity = 900; // px/s2
  const flapImpulse = -300; // px/s
  let pipes = [];
  let pipeGap = 170;
  let pipeW = 156;
  let spawnTimer = 0;
  let spawnInterval = 1.5; // seconds
  let score = 0;
  let high = localStorage.getItem('flappy_high')||0;
  let running = false, gameover=false;
  let last = performance.now()/1000;

  const hud = document.getElementById('hud');
  const scoreEl = document.getElementById('score');
  function start(){
    // reset
    w = canvas.width / devicePixelRatio; h = canvas.height / devicePixelRatio;
    bird = {x:80,y: h/2, vy:0, radius:14};
    pipes = [];
    spawnTimer = 0; score = 0; gameover = false; running = true; last = performance.now()/1000;
    hud.textContent = '';
    scoreEl.textContent = '0';
    document.getElementById('overlay').style.display='none';
  }

  function endGame(){
    running = false; gameover = true;
    document.getElementById('overlay').style.display='flex';
    const menu = document.getElementById('menu');
    menu.innerHTML = `<h2 style=\"margin:0 0 6px\">Game Over</h2><div>Score: ${score}</div><div>High: ${high}</div><button class=\"btn\" id=\"restart\">Play Again</button>`;
    document.getElementById('restart').addEventListener('click', ()=>{ start(); });
    if(score>high){ high = score; localStorage.setItem('flappy_high', high); }
  }

  function flap(){ if(!running){ start(); return; } bird.vy = flapImpulse; }

  // input
  window.addEventListener('keydown', e=>{ if(e.code==='Space'){ e.preventDefault(); flap(); } });
  canvas.addEventListener('mousedown', e=>{ flap(); });
  canvas.addEventListener('touchstart', e=>{ e.preventDefault(); flap(); }, {passive:false});
  document.getElementById('startBtn').addEventListener('click', ()=>start());

  // simple collision
  function intersectsPipe(px, gapY){
    const bx = bird.x, by = bird.y, r = bird.radius;
    if(bx + r > px && bx - r < px + pipeW){
      if(by - r < gapY || by + r > gapY + pipeGap) return true;
    }
    return false;
  }

  function step(dt){
    if(!running) return;
    // physics
    bird.vy += gravity * dt;
    bird.y += bird.vy * dt;

    spawnTimer += dt;
    if(spawnTimer > spawnInterval){ spawnTimer = 0; const gapY = 80 + Math.random()*(h - 220); pipes.push({x: w + 20, gapY}); }

    // move pipes
    for(let i=pipes.length-1;i>=0;i--){ const p = pipes[i]; p.x -= 140*dt; if(p.x + pipeW < 0) pipes.splice(i,1); }

    // score: pass pipe
    for(let p of pipes){ if(!p.passed && p.x + pipeW < bird.x - bird.radius){ p.passed = true; score++; scoreEl.textContent = score; } }

    // collisions
    if(bird.y + bird.radius > h || bird.y - bird.radius < 0) endGame();
    for(let p of pipes) if(intersectsPipe(p.x,p.gapY)) endGame();
  }

  function draw(){
    // clear
    ctx.clearRect(0,0,w,h);
    // background
    // ground
    ctx.fillStyle = '#6ee3b3'; ctx.fillRect(0,h-60,w,60);
    // pipes
    for(let p of pipes){
      ctx.fillStyle = '#3aa34a';
      ctx.fillRect(p.x,0,pipeW,p.gapY);
      ctx.fillRect(p.x,p.gapY+pipeGap,pipeW,h - (p.gapY+pipeGap) - 60);
      // pipe caps
      ctx.fillStyle = '#2e8c3d'; ctx.fillRect(p.x-2,p.gapY-8,pipeW+4,8); ctx.fillRect(p.x-2,p.gapY+pipeGap,pipeW+4,8);
    }
    // bird
    ctx.save();
    ctx.translate(bird.x, bird.y);
    const tilt = Math.max(-0.6, Math.min(0.8, bird.vy/400));
    ctx.rotate(tilt);
    // body
    ctx.fillStyle = '#ffdd57'; ctx.beginPath(); ctx.arc(0,0,bird.radius,0,Math.PI*2); ctx.fill();
    // eye
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(6,-4,5,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(7,-3,2,0,Math.PI*2); ctx.fill();
    // beak
    ctx.fillStyle='#ff8c2b'; ctx.beginPath(); ctx.moveTo(-2,4); ctx.lineTo(18,0); ctx.lineTo(-2,-6); ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  function loop(t){
    const now = t/1000; const dt = Math.min(0.032, now - last); last = now;
    step(dt); draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // friendly pause when page hidden
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ running=false; hud.textContent='Paused'; document.getElementById('overlay').style.display='flex'; } });

})();
</script>
</body>
</html>
